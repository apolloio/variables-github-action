import { Token, TokensFile } from './token_types.js'
import { isAlias, flattenTokensFile } from './token_import.js';
import fs from 'node:fs/promises';

const INPUT_DIR = 'tokens_new';
const OUTPUT_DIR = './dist'

async function main() {
  const tokensFilePaths = await fs.readdir(INPUT_DIR);
  if (!tokensFilePaths.length) {
    console.error('[tokens_to_css] ERR: No input files found. Did you run sync-figma-to-tokens?');
    return 1;
  }

  await ensureDir(OUTPUT_DIR);

  for (const filePath of tokensFilePaths) {
    await readTokensFileAndWriteToCssFile(filePath);
  }

  return 0;
}

async function ensureDir(dirpath: string): Promise<void> {
  try {
    await fs.stat(dirpath);
  } catch {
    await fs.mkdir(dirpath);
  }
}

// Read a token file exported from figma, convert it to CSS variables, and output the CSS
async function readTokensFileAndWriteToCssFile(filePath: string) {
  const tokensFileRaw = await fs.readFile(`${INPUT_DIR}/${filePath}`, 'utf-8');
  const tokensFile = JSON.parse(tokensFileRaw);
  const css = processJsonToCssVars(tokensFile);

  const outfileName = `${OUTPUT_DIR}/${filePath.replace('.json', '.scss')}`;
  // Output as a SCSS placeholder selector
  const rootSelector = '%' + filePath.replace('.json', '').replaceAll('.', '-').toLowerCase();
  await writeCssToFile(outfileName, css, rootSelector);

  console.log(`\u2705 Wrote ${outfileName}`);
}

const OUTPUT_HEADER = `/* This file is an autogenerated export from the Figma API */
/* stylelint-disable apollo-stylelint-plugin/prefer-css-variables -- This sheet defines variables and should not be linted with this rule. */`;

// Take an array of lines and write it as a CSS File
function writeCssToFile(outfileName: string, css: string[], rootSelector: string = ':root') {
  const outfileData = `${OUTPUT_HEADER}\n\n${rootSelector} {\n${css.map(line => indentLine(line)).join('\n')}\n}`;
  return fs.writeFile(outfileName, outfileData);
}

type TokenBasicValue = string | number | boolean;
// TODO: Support more types - https://tr.designtokens.org/format/#types
//       Work with design to better specify types in the Tokens library.
function basicValueFromToken(token: Token): TokenBasicValue {
  const value = token.$value;

  if (typeof value === 'object') {
    // see https://tr.designtokens.org/format/#composite-types
    // Apollo doesn't use these yet so this is just for future proofing.
    console.warn('[WARN] Found composite type, these are not yet supported');
    return '"composite_type_not_supported_error"';
  }
  if (typeof value === 'string') {
    if (isAlias(value)) {
      // Values surrounded by brackets are aliases, not primatives.
      return `var(${stringifyAliasToCssVar(value)})`;
    }

    if (token.$type === 'color') {
      return value;
    }

    // Values with whitespace are wrapped in quotes
    return value.includes(' ') ? `'${value}'` : value;
  }

  if (typeof value === 'boolean') {
    return value;
  }

  // Numeric values are assumed to be pixels. We should probably use strings instead?
  // Truncate to max of 4 decimal places.
  // Figma API is prone to floating point precision errors.
  return `${Number.parseFloat((value).toFixed(4))}px`;
}

// When processing a token set and we see a new group, add a header comment
// e.g. /* Color/Base/Neutral */
function emitGroupComment(prevGroup: string, nextGroup: string) {
  if (prevGroup === nextGroup) {
    // If the group has not changed, do not emit a comment
    return [ prevGroup, '' ];
  }
  let comment = `/* ${nextGroup} */\n`;
  if (prevGroup) {
    // For all but the first group, include a newline
    comment = `\n${comment}`;
  }

  return [ nextGroup, comment ];
}

// Some groups need post-processing from the values used by Figma to the values used by CSS
const GROUP_POST_PROCESSORS: { [key: string]: (token: TokenBasicValue) => TokenBasicValue } = {

  // Figma uses OpenType font weight names, but CSS uses numerical values.
  // Convert those names to numbers.
  'Typeface/Base/Weight': (value: TokenBasicValue): TokenBasicValue => {
    try {
      if (typeof value === 'number') {
        // If the value is already a number, return it
        return value;
      }

      if (typeof value !== 'string') {
        throw Error('Invalid value: Value must be a string, but got ' + value);
      }

      value = value.toLowerCase()

      // Based on https://learn.microsoft.com/en-us/typography/opentype/spec/os2#usweightclass
      const mappedValue = {
        'thin': 100,
        'extralight': 200,
        'ultralight': 200,
        'light': 300,
        'normal': 400,
        'regular': 400,
        'medium': 500,
        'semibold': 600,
        'demibold': 600,
        'bold': 700,
        'extrabold': 800,
        'ultrabold': 800,
        'extrablack': 900,
        'black': 900,
        'heavy': 900,
      }[value];

      if (typeof mappedValue === 'undefined') {
        throw Error(`Unknown value in group: ${value} is not a valid font weight`);
      }

      return mappedValue;
    } catch (e) {
      console.warn(`[Typeface/Base/Weight] Failed to postprocess token:`, e);
      return value;
    }
  }
}

function postprocessGroup(group: string, tokenValue: TokenBasicValue): TokenBasicValue {
  if (group in GROUP_POST_PROCESSORS) {
    return GROUP_POST_PROCESSORS[group](tokenValue);
  }
  return tokenValue;
}

// Process a TokensFile to an array of lines of CSS
function processJsonToCssVars(json: TokensFile) {
  const flatTokens = flattenTokensFile(json);
  let group = '';
  let comment = '';

  return Object.entries(flatTokens).map(([ key, token ]: [ key: string, token: Token ]) => {
    const nextGroup = key.split('/').slice(0, -1).join('/');
    [ group, comment ] = emitGroupComment(group, nextGroup);
    const basicValue = postprocessGroup(group, basicValueFromToken(token));
    return `${comment}--${stringifyTokenKeyToCssVar(key)}: ${basicValue};`;
  });
}

// Indent one or many lines with a given amount of whitespace
function indentLine(lines: string, tabstop = 2) {
  const whitespace = Array(tabstop).fill(' ').join('');
  return lines.split('\n').map(line =>
    line.length ? `${whitespace}${line.trim()}` : ''
  ).join('\n');
}

// e.g. "Color/Base/Alpha/Highlight-0" -> "color-base-alpha-highlight-0"
function stringifyTokenKeyToCssVar(tokenKey: string): string {
  return tokenKey
    .toLowerCase()
    .replaceAll(/[()]/g, '')  // Strip parenthesis
    .replaceAll(/[/ ]/g, '-') // Replace slashes or whitespace with dashes
}

function stringifyAliasToCssVar(alias: string): string {
  // e.g. {Color.Base.Red.Red-10} -> --color-base-red-red-10
  return '--' + alias
    .toLowerCase()
    .replaceAll('.', '-')
    .replaceAll(' ', '-')
    .replaceAll(/[{}()]/g, '')  // Strip unsupported characters
}

main().then(process.exit)
